Points learnt while doing backend(springboot)

# details of pom.xml
* <modelVersion> this specifies that POM model will be used.
* <parent> Inherits configuration from the spring-boot-starter-parent POM. The spring-boot-starter-parent 
    provides default configurations for Spring Boot projects, such as dependency versions and plugin configurations.
	To see final pom.xml with <parent>, you can view it using: 
	mvn help:effective-pom									# produce effective POM to stdout
	mvn help:effective-pom -Doutput=effective-pom.xml		# or write it to a file to inspect
# or write it to a file to inspect
mvn help:effective-pom -Doutput=effective-pom.xml
* <properties> tell that java 17 will be used.
* <dependency> it will tell which JARs will be downloaded.
    1. spring-boot-starter-web -> helps working with REST APIs.
    2. spring-boot-starter-data-jpa -> helps working with database.
    3. mysql-connector-java -> provides jdbc driver for mySQL connection.
    4. spring-boot-starter-security -> helps with authentication and authorization.
    5. lombok -> helps with generating boilerplate code, getters/setters/constructor
    6. spring-boot-starter-test -> provides testing libraries.
* <build> helps configuring the build process.
    <plugin> in that which is `spring-boot-maven-plugin` enables Spring Boot-specific tasks like 
    running the application (mvn spring-boot:run) and creating executable JARs.
    <exclude> is excluding lombok from final JAR to not increase the size of it as when .class is created,
    lombok's job is to create getter/setter/constructor, so all this is done at compile time which is in
    .class, so during runtime lombok wont be required


Details of Maven Scopes and Transitivity:

Maven dependency scopes affect how dependencies are included in various build phases and how they are propagated to dependent projects:

1. compile (default scope)
Example: spring-core
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
    <scope>compile</scope>
</dependency>
Why: Core framework classes needed throughout the application lifecycle. If your module depends on another module that uses spring-core, you'll get it transitively because it's needed for compilation and runtime.

2. provided
Example: javax.servlet-api
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <scope>provided</scope>
</dependency>
Why: Servlet containers like Tomcat already include this. It's transitive for compilation (so other modules can compile against servlet APIs) but won't be packaged to avoid conflicts with the container's version.

3. runtime
Example: mysql-connector-java (as used in our pom.xml)
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
Why: JDBC driver isn't needed for compilation (you code against JDBC interfaces), but required at runtime. Transitive because any module using your database layer needs the driver at runtime.

4. test
Example: spring-boot-starter-test (as used in our pom.xml)
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
Why: Testing frameworks are only needed for testing. NOT transitive because your module's tests are internal - other modules using your code don't need your test dependencies.

Details of application.properties

Maven lifecycle (what happens when you build)

1. `mvn clean`
     - Deletes the `target/` directory (removes compiled `.class` files, packaged JARs, and other build artifacts).
     - Start with a clean slate for the next build.

2. `mvn install` (runs the default lifecycle up to `install`)
     - Maven reads `pom.xml` to learn project coordinates, plugins, and dependencies.
     - Dependency & plugin resolution: checks `~/.m2/repository` for required jars/plugins; if missing, downloads them from remote repositories (e.g., Maven Central) and stores them in `~/.m2/repository`.
     - Runs lifecycle phases in order (each phase implies the previous ones):
         * `validate` — verify project structure and `pom.xml` are correct.
         * `compile` — compile `src/main/java` to `.class` files in `target/classes/`.
         * `test` — compile and run tests from `src/test/java` (build fails if tests fail unless skipped).
         * `package` — create a distributable artifact (for example `target/<artifactId>-<version>.jar`).
         * `install` — copy the packaged artifact into the local Maven repository (`~/.m2/repository`) so other local projects can consume it.

Local repository path format:
        ~/.m2/repository/<groupId with slashes>/<artifactId>/<version>/<artifactId>-<version>.jar

Example:
    If `groupId` = `com.example`, `artifactId` = `my-app`, `version` = `1.0`, then after `mvn install` you'll find:
        ~/.m2/repository/com/example/my-app/1.0/my-app-1.0.jar

Common flags:
    - `mvn -DskipTests install`  (compile tests but don't run them)
    - `mvn -Dmaven.test.skip=true install`  (skip compiling and running tests)
    - `mvn clean install`  (clean first, then build and install)

Important note:
    - `install` copies artifacts to your local machine only. Uploading to a remote repository (Nexus/Artifactory) requires `mvn deploy` and proper `distributionManagement` configuration.


Three ways to define/set a classpath (runtime)

1) Using the `-cp` (or `-classpath`) flag — one-off for that java (or javac) command
     - Linux/macOS example:
         java -cp /path/to/lib1.jar:/path/to/lib2.jar:/path/to/classes com.example.App
     - Windows example (use `;` as separator):
         java -cp C:\path\to\lib1.jar;C:\path\to\lib2.jar;C:\path\to\classes com.example.App

2) Using the `CLASSPATH` environment variable (persists for the shell session)
     - Linux/macOS:
         export CLASSPATH=/path/to/lib1.jar:/path/to/lib2.jar:/path/to/classes
         java com.example.App
     - Windows (Command Prompt):
         set CLASSPATH=C:\path\to\lib1.jar;C:\path\to\lib2.jar;C:\path\to\classes
         java com.example.App

3) Using Maven (automatic) — Maven builds the classpath from `pom.xml` for you
     - `mvn compile`         # sets up the compile classpath
     - `mvn test`            # sets up the test classpath
     - `mvn exec:java`       # sets up the runtime classpath and runs the app


For compile time (javac)

1) Use `javac -cp` to set the compile-time classpath:
     javac -cp /path/to/lib.jar src/main/java/com/example/App.java -d target/classes
